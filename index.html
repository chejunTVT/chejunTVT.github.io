<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-八股文2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%872/" class="article-date">
  <time class="dt-published" datetime="2022-07-15T15:38:07.000Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%872/">八股文2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="说说你对AOP的理解"><a href="#说说你对AOP的理解" class="headerlink" title="说说你对AOP的理解"></a>说说你对AOP的理解</h1><h2 id="AOP是一种编程思想-是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。"><a href="#AOP是一种编程思想-是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。" class="headerlink" title="AOP是一种编程思想,是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。"></a>AOP是一种编程思想,是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。</h2><pre><code>面向对象编程将程序抽象成各个层次的对象,而面向切面编程是将程序抽象成各个切面。所谓切面,相当于应用对象间的横切点,我们可以将其单独抽象为单独的模块。
AOP技术利用一种称为“横切”的技术,剖解开封装对象的内部,将影响多个类的公共行为封装到一个可重用的模块中,并将其命名为切面。所谓的切面,简单来说就是与业务无关,却为业务模块所共同调用的逻辑,将其封装起来便于减少系统的重复代码,降低模块的耦合度,有利用未来的可操作性和可维护性。
</code></pre>
<p>AOP可以有多种实现方式,而Spring AOP支持如下两种实现方式。 </p>
<ul>
<li>JDK动态代理：这是Java提供的动态代理技术,可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式,在接口的代理实例中织入代码。 </li>
<li>CGLib动态代理：采用底层的字节码技术,在运行时创建子类代理的实例。当目标对象不存在接口时,Spring AOP就会采用这种方式,在子类实例中织入代码。</li>
</ul>
<h1 id="redis的持久化策略"><a href="#redis的持久化策略" class="headerlink" title="redis的持久化策略"></a>redis的持久化策略</h1><p>reids的持久化方式有两种：RDB和AOF </p>
<ul>
<li>RDB：它是通过数据集快照的方式来记录redis中的所有数据，在某个时间段内，将数据写入一个临时文件中，持久化结束，用这个临时文件替换上次的持久化文件，达到数据恢复。好处：只有一个dump.rdb文件，便于存储，容灾性较好，性能最大化，子进程来完成写操作，主进程继续处理命令。缺点：数据安全性低，RDB是隔一段时间进行一次备份，在此期间，如果发生了异常，可能导致数据的不完整性。 </li>
<li>AOF：它是通过记录redis的所有命令，每执行一次就记录一次数据，保存在AOF文件中。优点：保证了数据的安全性和完整性，即便是中途宕机，也可以恢复过来。缺点：他的文件比RDB文件大，如果是数据集大的时候，他的恢复速度比RDB文件慢，启动速度也慢。 Redis默认是用RDB文件存储。</li>
</ul>
<h1 id="请你说说虚拟内存和物理内存的区别"><a href="#请你说说虚拟内存和物理内存的区别" class="headerlink" title="请你说说虚拟内存和物理内存的区别"></a>请你说说虚拟内存和物理内存的区别</h1><h2 id="物理内存：计算机中真实拥有的内存。物理内存是有限的，容易产生内存不足问题。虚拟内存是一种抽象的逻辑概念，拥有连续的内存地址。"><a href="#物理内存：计算机中真实拥有的内存。物理内存是有限的，容易产生内存不足问题。虚拟内存是一种抽象的逻辑概念，拥有连续的内存地址。" class="headerlink" title="物理内存：计算机中真实拥有的内存。物理内存是有限的，容易产生内存不足问题。虚拟内存是一种抽象的逻辑概念，拥有连续的内存地址。"></a>物理内存：计算机中真实拥有的内存。物理内存是有限的，容易产生内存不足问题。虚拟内存是一种抽象的逻辑概念，拥有连续的内存地址。</h2><h1 id="说说你对IoC的理解"><a href="#说说你对IoC的理解" class="headerlink" title="说说你对IoC的理解"></a>说说你对IoC的理解</h1><h2 id="IoC：控制反转。控制：对象的创建的控制权限；反转：将对象的控制权限交给spring。之前我们创建对象时用new，现在直接从spring容器中取，维护对象之间的依赖关系，降低对象之间的耦合度。-实现方式为DI-依赖注入，有三种注入方式：构造器、setter、接口注入"><a href="#IoC：控制反转。控制：对象的创建的控制权限；反转：将对象的控制权限交给spring。之前我们创建对象时用new，现在直接从spring容器中取，维护对象之间的依赖关系，降低对象之间的耦合度。-实现方式为DI-依赖注入，有三种注入方式：构造器、setter、接口注入" class="headerlink" title="IoC：控制反转。控制：对象的创建的控制权限；反转：将对象的控制权限交给spring。之前我们创建对象时用new，现在直接从spring容器中取，维护对象之间的依赖关系，降低对象之间的耦合度。 实现方式为DI,依赖注入，有三种注入方式：构造器、setter、接口注入"></a>IoC：控制反转。控制：对象的创建的控制权限；反转：将对象的控制权限交给spring。之前我们创建对象时用new，现在直接从spring容器中取，维护对象之间的依赖关系，降低对象之间的耦合度。 实现方式为DI,依赖注入，有三种注入方式：构造器、setter、接口注入</h2><h1 id="请你说说内存管理"><a href="#请你说说内存管理" class="headerlink" title="请你说说内存管理"></a>请你说说内存管理</h1><h2 id="linux操作系统采用段页式内存管理方式：页式存储管理可以有效的提高内存利用率，段式内存管理能反映程序的逻辑结构并有利于段的共享。将这两种方法结合起来就形成了段页式储存管理方式。段页式储存管理方式就是先建好用户程序分成若干个段，再把每个段分成若干页，并为每个段赋予一个段名。"><a href="#linux操作系统采用段页式内存管理方式：页式存储管理可以有效的提高内存利用率，段式内存管理能反映程序的逻辑结构并有利于段的共享。将这两种方法结合起来就形成了段页式储存管理方式。段页式储存管理方式就是先建好用户程序分成若干个段，再把每个段分成若干页，并为每个段赋予一个段名。" class="headerlink" title="linux操作系统采用段页式内存管理方式：页式存储管理可以有效的提高内存利用率，段式内存管理能反映程序的逻辑结构并有利于段的共享。将这两种方法结合起来就形成了段页式储存管理方式。段页式储存管理方式就是先建好用户程序分成若干个段，再把每个段分成若干页，并为每个段赋予一个段名。"></a>linux操作系统采用段页式内存管理方式：页式存储管理可以有效的提高内存利用率，段式内存管理能反映程序的逻辑结构并有利于段的共享。将这两种方法结合起来就形成了段页式储存管理方式。段页式储存管理方式就是先建好用户程序分成若干个段，再把每个段分成若干页，并为每个段赋予一个段名。</h2><h1 id="请你说说IO多路复用（select、poll、epoll）"><a href="#请你说说IO多路复用（select、poll、epoll）" class="headerlink" title="请你说说IO多路复用（select、poll、epoll）"></a>请你说说IO多路复用（select、poll、epoll）</h1><h2 id="IO多路复用是指单个线程或进程能够处理多个IO请求。select调用主要统计有多少个文件描述符需要进行IO操作。缺点：内存开销大，支持的的文件描述符的个数有限。poll和select调用差别不大，主要是底层数据结构变成了链表，支持的文件描述符的个数无上限。epoll调用是更加高效的方式，底层数据结构使用了红黑树和链表，避免了大量的内存分配和轮询。"><a href="#IO多路复用是指单个线程或进程能够处理多个IO请求。select调用主要统计有多少个文件描述符需要进行IO操作。缺点：内存开销大，支持的的文件描述符的个数有限。poll和select调用差别不大，主要是底层数据结构变成了链表，支持的文件描述符的个数无上限。epoll调用是更加高效的方式，底层数据结构使用了红黑树和链表，避免了大量的内存分配和轮询。" class="headerlink" title="IO多路复用是指单个线程或进程能够处理多个IO请求。select调用主要统计有多少个文件描述符需要进行IO操作。缺点：内存开销大，支持的的文件描述符的个数有限。poll和select调用差别不大，主要是底层数据结构变成了链表，支持的文件描述符的个数无上限。epoll调用是更加高效的方式，底层数据结构使用了红黑树和链表，避免了大量的内存分配和轮询。"></a>IO多路复用是指单个线程或进程能够处理多个IO请求。select调用主要统计有多少个文件描述符需要进行IO操作。缺点：内存开销大，支持的的文件描述符的个数有限。poll和select调用差别不大，主要是底层数据结构变成了链表，支持的文件描述符的个数无上限。epoll调用是更加高效的方式，底层数据结构使用了红黑树和链表，避免了大量的内存分配和轮询。</h2><h1 id="请你说说MySQL的事务隔离级别"><a href="#请你说说MySQL的事务隔离级别" class="headerlink" title="请你说说MySQL的事务隔离级别"></a>请你说说MySQL的事务隔离级别</h1><h2 id="事务的隔离级别有：未提交读，提交读，可重复读，串行化四种隔离级别。-数据库多个事务同时执行时可能造成事务的一致性问题：脏读，不可重复读，幻读；-提交读可以解决脏读的问题：脏读就是线程A修改一个数据，没有提交，线程B读取了这个修改的数据之后线程A回滚，线程B读取到的数据就变成了脏数据。-可重复读可以解决脏读和不可重复度的问题，不可重复读就是事务A多次读取一个数据，事务B在A读取的过程中进行了修改，导致事务A多次读取到的数据不一致。-串行化可以同时解决三个问题，幻读就是事务A对一个表进行读取，事务B在A读取的时候增减或者删除数据，导致事务A读取到的数据并不一致。"><a href="#事务的隔离级别有：未提交读，提交读，可重复读，串行化四种隔离级别。-数据库多个事务同时执行时可能造成事务的一致性问题：脏读，不可重复读，幻读；-提交读可以解决脏读的问题：脏读就是线程A修改一个数据，没有提交，线程B读取了这个修改的数据之后线程A回滚，线程B读取到的数据就变成了脏数据。-可重复读可以解决脏读和不可重复度的问题，不可重复读就是事务A多次读取一个数据，事务B在A读取的过程中进行了修改，导致事务A多次读取到的数据不一致。-串行化可以同时解决三个问题，幻读就是事务A对一个表进行读取，事务B在A读取的时候增减或者删除数据，导致事务A读取到的数据并不一致。" class="headerlink" title="事务的隔离级别有：未提交读，提交读，可重复读，串行化四种隔离级别。 数据库多个事务同时执行时可能造成事务的一致性问题：脏读，不可重复读，幻读； 提交读可以解决脏读的问题：脏读就是线程A修改一个数据，没有提交，线程B读取了这个修改的数据之后线程A回滚，线程B读取到的数据就变成了脏数据。 可重复读可以解决脏读和不可重复度的问题，不可重复读就是事务A多次读取一个数据，事务B在A读取的过程中进行了修改，导致事务A多次读取到的数据不一致。 串行化可以同时解决三个问题，幻读就是事务A对一个表进行读取，事务B在A读取的时候增减或者删除数据，导致事务A读取到的数据并不一致。"></a>事务的隔离级别有：未提交读，提交读，可重复读，串行化四种隔离级别。 数据库多个事务同时执行时可能造成事务的一致性问题：脏读，不可重复读，幻读； 提交读可以解决脏读的问题：脏读就是线程A修改一个数据，没有提交，线程B读取了这个修改的数据之后线程A回滚，线程B读取到的数据就变成了脏数据。 可重复读可以解决脏读和不可重复度的问题，不可重复读就是事务A多次读取一个数据，事务B在A读取的过程中进行了修改，导致事务A多次读取到的数据不一致。 串行化可以同时解决三个问题，幻读就是事务A对一个表进行读取，事务B在A读取的时候增减或者删除数据，导致事务A读取到的数据并不一致。</h2><h1 id="如何利用Redis实现一个分布式锁？"><a href="#如何利用Redis实现一个分布式锁？" class="headerlink" title="如何利用Redis实现一个分布式锁？"></a>如何利用Redis实现一个分布式锁？</h1><h2 id="最简单redis分布式锁的实现方式：加锁：setnx（key-1），解锁：del-key-问题：如果客户忘记解锁，将会出现死锁。第二种分布式锁的实现方式：setnx-key-1-expire-key-30-解锁：del-key-问题：由于setnx和expire的非原子性，当第二步挂掉，仍然会出现死锁。第三种方式：加锁：将setnx和expire变成原子性操作，set-key-1-30-NX-解锁：del（key）。同时考虑到线程A还在执行，但是锁已经到期，当线程A执行结束时去释放锁时，可能就会释放别的线程锁，所以在解锁时要先判断一下value值，看是不是该锁，如果是，再进行删除。"><a href="#最简单redis分布式锁的实现方式：加锁：setnx（key-1），解锁：del-key-问题：如果客户忘记解锁，将会出现死锁。第二种分布式锁的实现方式：setnx-key-1-expire-key-30-解锁：del-key-问题：由于setnx和expire的非原子性，当第二步挂掉，仍然会出现死锁。第三种方式：加锁：将setnx和expire变成原子性操作，set-key-1-30-NX-解锁：del（key）。同时考虑到线程A还在执行，但是锁已经到期，当线程A执行结束时去释放锁时，可能就会释放别的线程锁，所以在解锁时要先判断一下value值，看是不是该锁，如果是，再进行删除。" class="headerlink" title="最简单redis分布式锁的实现方式：加锁：setnx（key,1），解锁：del(key),问题：如果客户忘记解锁，将会出现死锁。第二种分布式锁的实现方式：setnx(key,1)+expire(key,30),解锁：del(key).问题：由于setnx和expire的非原子性，当第二步挂掉，仍然会出现死锁。第三种方式：加锁：将setnx和expire变成原子性操作，set(key,1,30,NX),解锁：del（key）。同时考虑到线程A还在执行，但是锁已经到期，当线程A执行结束时去释放锁时，可能就会释放别的线程锁，所以在解锁时要先判断一下value值，看是不是该锁，如果是，再进行删除。"></a>最简单redis分布式锁的实现方式：加锁：setnx（key,1），解锁：del(key),问题：如果客户忘记解锁，将会出现死锁。第二种分布式锁的实现方式：setnx(key,1)+expire(key,30),解锁：del(key).问题：由于setnx和expire的非原子性，当第二步挂掉，仍然会出现死锁。第三种方式：加锁：将setnx和expire变成原子性操作，set(key,1,30,NX),解锁：del（key）。同时考虑到线程A还在执行，但是锁已经到期，当线程A执行结束时去释放锁时，可能就会释放别的线程锁，所以在解锁时要先判断一下value值，看是不是该锁，如果是，再进行删除。</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%872/" data-id="cl5m4giz3000084uofarb88kc" data-title="八股文2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-八股文1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/17/%E5%85%AB%E8%82%A1%E6%96%871/" class="article-date">
  <time class="dt-published" datetime="2022-06-17T02:32:07.000Z" itemprop="datePublished">2022-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/17/%E5%85%AB%E8%82%A1%E6%96%871/">八股文1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="说说你对MVC的理解"><a href="#说说你对MVC的理解" class="headerlink" title="说说你对MVC的理解"></a>说说你对MVC的理解</h1><h2 id="MVC是一种设计模式-在这种模式下软件被分为三层-即Model（模型）、View（视图）、Controller（控制器）。Model代表的是数据-View代表的是用户界面-Controller代表的是数据的处理逻辑-它是Model和View这两层的桥梁。将软件分层的好处是-可以将对象之间的耦合度降低-便于代码的维护。"><a href="#MVC是一种设计模式-在这种模式下软件被分为三层-即Model（模型）、View（视图）、Controller（控制器）。Model代表的是数据-View代表的是用户界面-Controller代表的是数据的处理逻辑-它是Model和View这两层的桥梁。将软件分层的好处是-可以将对象之间的耦合度降低-便于代码的维护。" class="headerlink" title="MVC是一种设计模式,在这种模式下软件被分为三层,即Model（模型）、View（视图）、Controller（控制器）。Model代表的是数据,View代表的是用户界面,Controller代表的是数据的处理逻辑,它是Model和View这两层的桥梁。将软件分层的好处是,可以将对象之间的耦合度降低,便于代码的维护。"></a>MVC是一种设计模式,在这种模式下软件被分为三层,即Model（模型）、View（视图）、Controller（控制器）。Model代表的是数据,View代表的是用户界面,Controller代表的是数据的处理逻辑,它是Model和View这两层的桥梁。将软件分层的好处是,可以将对象之间的耦合度降低,便于代码的维护。</h2><ul>
<li>Model：指从现实世界中抽象出来的对象模型,是应用逻辑的反应；它封装了数据和对数据的操作,是实际进行数据处理的地方（模型层与数据库才有交互）。在MVC的三个部件中,模型拥有最多的处理任务。被模型返回的数据是中立的,模型与数据格式无关,这样一个模型能为多个视图提供数据,由于应用于模型的代码只需写一次就可以被多个视图重用,所以减少了代码的重复性。</li>
<li>View：负责进行模型的展示,一般就是我们见到的用户界面。 </li>
<li>Controller：控制器负责视图和模型之间的交互,控制对用户输入的响应、响应方式和流程；它主要负责两方面的动作,一是把用户的请求分发到相应的模型,二是吧模型的改变及时地反映到视图上。</li>
</ul>
<h1 id="详细的说说Redis的数据类型"><a href="#详细的说说Redis的数据类型" class="headerlink" title="详细的说说Redis的数据类型"></a>详细的说说Redis的数据类型</h1><h2 id="Redis主要提供了5种数据结构：字符串-string-、哈希-hash-、列表-list-、集合-set-、有序集合-zset-。Redis还提供了Bitmap、HyperLogLog、Geo类型-但这些类型都是基于上述核心数据类型实现的。"><a href="#Redis主要提供了5种数据结构：字符串-string-、哈希-hash-、列表-list-、集合-set-、有序集合-zset-。Redis还提供了Bitmap、HyperLogLog、Geo类型-但这些类型都是基于上述核心数据类型实现的。" class="headerlink" title="Redis主要提供了5种数据结构：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)。Redis还提供了Bitmap、HyperLogLog、Geo类型,但这些类型都是基于上述核心数据类型实现的。"></a>Redis主要提供了5种数据结构：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)。Redis还提供了Bitmap、HyperLogLog、Geo类型,但这些类型都是基于上述核心数据类型实现的。</h2><ul>
<li>string可以存储字符串、数字和二进制数据,除了值可以是String以外,所有的键也可以是string,string最大可以存储大小为2M的数据。 </li>
<li>list保证数据线性有序且元素可重复,它支持lpush、blpush、rpop、brpop等操作,可以当作简单的消息队列使用,一个list最多可以存储2^32-1个元素 </li>
<li>hash的值本身也是一个键值对结构,最多能存储2^32-1个元素 </li>
<li>set是无序不可重复的,它支持多个set求交集、并集、差集,适合实现共同关注之类的需求,一个set最多可以存储2^32-1个元素 </li>
<li>zset是有序不可重复的,它通过给每个元素设置一个分数来作为排序的依据,一个zset最多可以存储2^32-1个元素。</li>
</ul>
<h1 id="请你说说乐观锁和悲观锁"><a href="#请你说说乐观锁和悲观锁" class="headerlink" title="请你说说乐观锁和悲观锁"></a>请你说说乐观锁和悲观锁</h1><h2 id="乐观锁：乐观锁总是假设最好的情况-每次去拿数据的时候都认为别人不会修改-所以不会上锁-但是在更新的时候会判断一下在此期间别人有没有去更新这个数据-可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型-这样可以提高吞吐量-像数据库提供的类似于write-condition机制-其实都是提供的乐观锁"><a href="#乐观锁：乐观锁总是假设最好的情况-每次去拿数据的时候都认为别人不会修改-所以不会上锁-但是在更新的时候会判断一下在此期间别人有没有去更新这个数据-可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型-这样可以提高吞吐量-像数据库提供的类似于write-condition机制-其实都是提供的乐观锁" class="headerlink" title="乐观锁：乐观锁总是假设最好的情况,每次去拿数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型,这样可以提高吞吐量,像数据库提供的类似于write_condition机制,其实都是提供的乐观锁"></a>乐观锁：乐观锁总是假设最好的情况,每次去拿数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型,这样可以提高吞吐量,像数据库提供的类似于write_condition机制,其实都是提供的乐观锁</h2><h2 id="悲观锁：悲观锁总是假设最坏的情况-每次去拿数据的时候都认为别人会修改-所以每次在拿数据的时候都会上锁-这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用-其它线程阻塞-用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制-比如行锁-表锁等-读锁-写锁等-都是在做操作之前先上锁。"><a href="#悲观锁：悲观锁总是假设最坏的情况-每次去拿数据的时候都认为别人会修改-所以每次在拿数据的时候都会上锁-这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用-其它线程阻塞-用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制-比如行锁-表锁等-读锁-写锁等-都是在做操作之前先上锁。" class="headerlink" title="悲观锁：悲观锁总是假设最坏的情况,每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用,其它线程阻塞,用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制,比如行锁,表锁等,读锁,写锁等,都是在做操作之前先上锁。"></a>悲观锁：悲观锁总是假设最坏的情况,每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用,其它线程阻塞,用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制,比如行锁,表锁等,读锁,写锁等,都是在做操作之前先上锁。</h2><h1 id="设计模式了解么"><a href="#设计模式了解么" class="headerlink" title="设计模式了解么"></a>设计模式了解么</h1><ul>
<li>创建型包括：单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式； </li>
<li>结构型包括：代理模式、装饰模式、适配器模式、组合模式、桥梁模式、外观模式和享元模式； </li>
<li>行为型包括：模板方法模式、命令模式、责任链模式、策略模式、迭代器模式、中介者模式、观察者模式、备忘录模式、访问者模式、状态模式和解释器模式。 面试中不要求23种设计模式全部了解,但至少应掌握单例模式和工厂模式。</li>
</ul>
<p>单例模式（Singleton Pattern）是最简单的创建型设计模式。它会确保一个类只有一个实例存在。单例模式最重要的特点就是构造函数私有,从而避免外界直接使用构造函数直接实例化该类的对象。 </p>
<p>单例模式在Java种通常有两种表现形式： - 饿汉式：类加载时就进行对象实例化 - 懒汉式：第一次引用类时才进行对象实例化 </p>
<p>饿汉式单例模式： 在类被加载时就会初始化静态变量instance,这时候类的私有构造函数就会被调用,创建唯一的实例。 </p>
<p>public class Singleton<br>{ </p>
<pre><code>private static Singleton instance = new Singleton(); // 构造方法私有,确保外界不能直接实例化 

private Singleton()&#123; &#125; //通过公有的静态方法获取对象实例 

public static Singleton getInstance()
&#123; return instance; &#125; 
</code></pre>
<p>} </p>
<p>懒汉式单例模式： 类在加载时不会初始化静态变量instance,而是在第一次被调用时将自己初始化 </p>
<p>public class Singleton </p>
<p>{ </p>
<pre><code>private static Singleton instance = null; // 私有构造方法,确保外界不能直接实例化。 

private Singleton() &#123;&#125; // 通过公有的静态方法获取对象实例 public static 

Singleton getInstace() &#123; 
    
    if (instance == null) 
    
    &#123; instance = new Singleton(); &#125; return instance; &#125; 
    
   
</code></pre>
<p> } </p>
<pre><code>    但这时有一个问题,如果线程A和B同时调用此方法,会出现执行`if (instance == null)`语句时都为真的情况,那么线程AB都会创建一个对象,那内存中就会出现两个对象,这违反了单例模式的定义。为解决这一问题,可以使用synchronized关键字对静态方法 getInstance()进行同步,线程安全的的懒汉式单例模式代码如下： 
    
    public class Singleton 
    &#123; 
        
        private static Singleton instance = null; // 私有构造方法,确保外界不能直接实例化。 
        
        private Singleton() &#123;&#125; // 通过公有的静态方法获取对象实例 
        
        synchronized public static Singleton getInstace() &#123; 
            if (instance == null) &#123; instance = new Singleton(); &#125; 
        
        return instance; &#125; 
        
    &#125; 
        
        饿汉式单例类在资源利用效率上不如懒汉式单例类,但从速度和反应时间来看,饿汉式单例类要优于懒汉式单例类。
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/17/%E5%85%AB%E8%82%A1%E6%96%871/" data-id="cl5m3roz00000jcuo065959zh" data-title="八股文1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-八股文" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/13/%E5%85%AB%E8%82%A1%E6%96%87/" class="article-date">
  <time class="dt-published" datetime="2022-06-13T14:38:08.000Z" itemprop="datePublished">2022-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/13/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h1><ul>
<li><ol>
<li>进程有独立的地址空间,线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间；</li>
</ol>
</li>
<li><ol start="2">
<li>进程和线程切换时,需要切换进程和线程的上下文,进程的上下文切换时间开销远远大于线程上下文切换时间,耗费资源较大,效率要差一些；</li>
</ol>
</li>
<li><ol start="3">
<li>进程的并发性较低,线程的并发性较高；</li>
</ol>
</li>
<li><ol start="4">
<li>每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口,但是线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制；</li>
</ol>
</li>
<li><ol start="5">
<li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言,除了 CPU 外,系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源）,线程组之间只能共享资源；</li>
</ol>
</li>
<li><ol start="6">
<li>一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>
</ol>
</li>
</ul>
<p>得分点 地址空间、开销、并发性、内存</p>
<h1 id="请你说说MySQL索引-以及它们的好处和坏处"><a href="#请你说说MySQL索引-以及它们的好处和坏处" class="headerlink" title="请你说说MySQL索引,以及它们的好处和坏处"></a>请你说说MySQL索引,以及它们的好处和坏处</h1><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li>索引就像指向表行的指针,是一种允许查询操作快速确定哪些行符合WHERE子句中的条件,并检索到这些行的其他列值的数据结构；</li>
<li>索引主要有普通索引、唯一索引、主键索引、外键索引、全文索引、复合索引几种； </li>
<li>在大数据量的查询中,合理使用索引的优点非常明显,不仅能大幅提高匹配where条件的检索效率,还能用于排序和分组操作的加速。<h2 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h2></li>
<li>比如索引必定会增加存储资源的消耗；</li>
<li>同时也增大了插入、更新和删除操作的维护成本,因为每个增删改操作后相应列的索引都必须被更新。<h1 id="Java基本数据类型和引用类型"><a href="#Java基本数据类型和引用类型" class="headerlink" title="Java基本数据类型和引用类型"></a>Java基本数据类型和引用类型</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2></li>
<li>分别为整数类型byte&#x2F;short&#x2F;int&#x2F;long,浮点类型float&#x2F;double，字符类型char，布尔类型boolean</li>
<li>引用类型包括数组、类、接口类型，还有一种特殊的null类型</li>
</ul>
<h1 id="请介绍一下访问修饰符"><a href="#请介绍一下访问修饰符" class="headerlink" title="请介绍一下访问修饰符"></a>请介绍一下访问修饰符</h1><ul>
<li>java提供的三个访问修饰符分别表示三个访问级别之外还有一个不加修饰符的访问级别</li>
<li>访问级别控制从小到大分别为private、default、protected、public</li>
<li>private：类中被private修饰的成员只能在当前类的内部被访问。根据这点,我们可以使用它来修饰成员变量,从而将成员变量隐藏在这个类的内部。</li>
<li>default：如果类中的成员或者一个外部类不使用任何访问修饰符来进行修饰,那么他就是default级别的,default访问控制的类成员或者外部类可以被相同包下的其他类访问。</li>
<li>protected：如果一个类成员被protected访问修饰符修饰,那么这个成员不但可以被同一个包下的其他类访问,还可以被其他包下的子类访问。</li>
<li>public：这是Java中最宽松的访问级别,如果类成员被这个修饰符修饰,那么无论访问类和被访问类在不在一个包下,有没有父子关系,这个类成员都可以被访问到。</li>
</ul>
<h1 id="请你介绍一下数据库的ACID"><a href="#请你介绍一下数据库的ACID" class="headerlink" title="请你介绍一下数据库的ACID"></a>请你介绍一下数据库的ACID</h1><p>事务需遵循ACID四个特性： </p>
<ul>
<li>A（atomicity）,原子性。原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功,整个事务的执行才算成功。事务中任何一个SQL语句执行失败,那么已经执行成功的SQL语句也必须撤销,数据库状态应该退回到执行事务前的状态。 </li>
<li>C（consistency）,一致性。一致性指事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后,数据库的完整性约束没有被破坏。</li>
<li>I（isolation）,隔离性。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离,即该事务提交前对其他事务都不可见,这通常使用锁来实现。 </li>
<li>D（durability）,持久性.事务一旦提交,其结果就是永久性的,即使发生宕机等故障,数据库也能将数据恢复。持久性保证的是事务系统的高可靠性,而不是高可用性。</li>
</ul>
<h1 id="请你说说多线程"><a href="#请你说说多线程" class="headerlink" title="请你说说多线程"></a>请你说说多线程</h1><ul>
<li>线程是操作系统调度的最小单位,它可以让一个进程并发地处理多个任务,也叫轻量级进程。</li>
<li>在一个进程里可以创建多个线程,这些线程都拥有各自的计数器、堆栈、局部变量,并且能够共享进程内的资源。</li>
<li>由于共享资源,处理器便可以在这些线程之间快速切换,从而让使用者感觉这些线程在同时执行。</li>
</ul>
<p>总的来说,操作系统可以同时执行多个任务,每个任务就是一个进程。进程可以同时执行多个任务,每个任务就是一个线程。一个程序运行之后至少有一个进程,而一个进程可以包含多个线程,但至少要包含一个线程。</p>
<h3 id="使用多线程的原因主要有以下几点："><a href="#使用多线程的原因主要有以下几点：" class="headerlink" title="使用多线程的原因主要有以下几点："></a>使用多线程的原因主要有以下几点：</h3><ul>
<li><ol>
<li>更多的CPU核心</li>
</ol>
</li>
<li><ol start="2">
<li>更快的响应时间</li>
</ol>
</li>
<li><ol start="3">
<li>更好的编程模型</li>
</ol>
</li>
</ul>
<h1 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全"></a>怎么保证线程安全</h1><h2 id="Java保证线程安全的方式有很多-其中较为常用的有三种-按照资源占用情况由轻到重排列-这三种保证线程安全的方式分别是原子类、volatile、锁。"><a href="#Java保证线程安全的方式有很多-其中较为常用的有三种-按照资源占用情况由轻到重排列-这三种保证线程安全的方式分别是原子类、volatile、锁。" class="headerlink" title="Java保证线程安全的方式有很多,其中较为常用的有三种,按照资源占用情况由轻到重排列,这三种保证线程安全的方式分别是原子类、volatile、锁。"></a>Java保证线程安全的方式有很多,其中较为常用的有三种,按照资源占用情况由轻到重排列,这三种保证线程安全的方式分别是原子类、volatile、锁。</h2><ul>
<li>JDK从1.5开始提供了java.util.concurrent.atomic包,这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。在atomic包里一共提供了17个类,按功能可以归纳为4种类型的原子更新方式,分别是原子更新基本类型、原子更新引用类型、原子更新属性、原子更新数组。无论原子更新哪种类型,都要遵循“比较和替换”规则,即比较要更新的值是否等于期望值,如果是则更新,如果不是则失败。</li>
<li>volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性”,从而可以保证单个变量读写时的线程安全。</li>
<li>原子类和volatile只能保证单个共享变量的线程安全,锁则可以保证临界区内的多个共享变量的线程安全,Java中加锁的方式有两种,分别是synchronized关键字和Lock接口。synchronized是比较早期的API,在设计之初没有考虑到超时机制、非阻塞形式,以及多个条件变量。<h3 id="synchronized是比较早期的API-在设计之初没有考虑到超时机制、非阻塞形式-以及多个条件变量。若想通过升级的方式让它支持这些相对复杂的功能-则需要大改它的语法结构-不利于兼容旧代码。JDK的开发团队在1-5新增了Lock接口-并通过Lock支持了上述的功能-即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。"><a href="#synchronized是比较早期的API-在设计之初没有考虑到超时机制、非阻塞形式-以及多个条件变量。若想通过升级的方式让它支持这些相对复杂的功能-则需要大改它的语法结构-不利于兼容旧代码。JDK的开发团队在1-5新增了Lock接口-并通过Lock支持了上述的功能-即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。" class="headerlink" title="synchronized是比较早期的API,在设计之初没有考虑到超时机制、非阻塞形式,以及多个条件变量。若想通过升级的方式让它支持这些相对复杂的功能,则需要大改它的语法结构,不利于兼容旧代码。JDK的开发团队在1.5新增了Lock接口,并通过Lock支持了上述的功能,即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。"></a>synchronized是比较早期的API,在设计之初没有考虑到超时机制、非阻塞形式,以及多个条件变量。若想通过升级的方式让它支持这些相对复杂的功能,则需要大改它的语法结构,不利于兼容旧代码。JDK的开发团队在1.5新增了Lock接口,并通过Lock支持了上述的功能,即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。</h3></li>
</ul>
<h1 id="请你说说死锁定义及发生的条件"><a href="#请你说说死锁定义及发生的条件" class="headerlink" title="请你说说死锁定义及发生的条件"></a>请你说说死锁定义及发生的条件</h1><h2 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h2><h3 id="两个或两个以上的进程在执行过程中-因争夺共享资源而造成的一种互相等待的现象-若无外力作用-它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。"><a href="#两个或两个以上的进程在执行过程中-因争夺共享资源而造成的一种互相等待的现象-若无外力作用-它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。" class="headerlink" title="两个或两个以上的进程在执行过程中,因争夺共享资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。"></a>两个或两个以上的进程在执行过程中,因争夺共享资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。</h3><h2 id="2-死锁的发生必须具备以下四个必要条件："><a href="#2-死锁的发生必须具备以下四个必要条件：" class="headerlink" title="2.死锁的发生必须具备以下四个必要条件："></a>2.死锁的发生必须具备以下四个必要条件：</h2><ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用,即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源,则请求者只能等待,直至占有资源的进程用毕释放；  </li>
<li>请求和保持条件：指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已被其它进程占有,此时请求进程阻塞,但又对自己已获得的其它资源保持不放； </li>
<li>不剥夺条件：指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放； </li>
<li>环路等待条件：指在发生死锁时,必然存在一个进程——资源的环形链,即进程集合 {P0,P1,P2,···,Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源,……,Pn 正在等待已被 P0 占用的资源。</li>
</ul>
<h1 id="请你说说进程间的通信方式"><a href="#请你说说进程间的通信方式" class="headerlink" title="请你说说进程间的通信方式"></a>请你说说进程间的通信方式</h1><h2 id="进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket"><a href="#进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket" class="headerlink" title="进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket"></a>进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket</h2><h2 id="1-管道-管道也叫无名（匿名）管道-它是是-UNIX-系统-IPC（进程间通信）的最古老形式-所有的-UNIX-系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区-Linux-系统中通过-pipe-函数创建管道-会生成两个文件描述符-分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。"><a href="#1-管道-管道也叫无名（匿名）管道-它是是-UNIX-系统-IPC（进程间通信）的最古老形式-所有的-UNIX-系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区-Linux-系统中通过-pipe-函数创建管道-会生成两个文件描述符-分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。" class="headerlink" title="1. 管道 管道也叫无名（匿名）管道,它是是 UNIX 系统 IPC（进程间通信）的最古老形式,所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区,Linux 系统中通过 pipe() 函数创建管道,会生成两个文件描述符,分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。"></a>1. 管道 管道也叫无名（匿名）管道,它是是 UNIX 系统 IPC（进程间通信）的最古老形式,所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区,Linux 系统中通过 pipe() 函数创建管道,会生成两个文件描述符,分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。</h2><h2 id="2-命名管道-匿名管道-由于没有名字-只能用于亲缘关系的进程间通信。为了克服这个缺点-提出了有名管道（FIFO）-也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联-以-FIFO-的文件形式存在于文件系统中-并且其打开方式与打开一个普通文件是一样的-这样即使与-FIFO-的创建进程不存在亲缘关系的进程-只要可以访问该路径-就能够彼此通过-FIFO-相互通信-因此-通过-FIFO-不相关的进程也能交换数据。"><a href="#2-命名管道-匿名管道-由于没有名字-只能用于亲缘关系的进程间通信。为了克服这个缺点-提出了有名管道（FIFO）-也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联-以-FIFO-的文件形式存在于文件系统中-并且其打开方式与打开一个普通文件是一样的-这样即使与-FIFO-的创建进程不存在亲缘关系的进程-只要可以访问该路径-就能够彼此通过-FIFO-相互通信-因此-通过-FIFO-不相关的进程也能交换数据。" class="headerlink" title="2. 命名管道 匿名管道,由于没有名字,只能用于亲缘关系的进程间通信。为了克服这个缺点,提出了有名管道（FIFO）,也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联,以 FIFO 的文件形式存在于文件系统中,并且其打开方式与打开一个普通文件是一样的,这样即使与 FIFO 的创建进程不存在亲缘关系的进程,只要可以访问该路径,就能够彼此通过 FIFO 相互通信,因此,通过 FIFO 不相关的进程也能交换数据。"></a>2. 命名管道 匿名管道,由于没有名字,只能用于亲缘关系的进程间通信。为了克服这个缺点,提出了有名管道（FIFO）,也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联,以 FIFO 的文件形式存在于文件系统中,并且其打开方式与打开一个普通文件是一样的,这样即使与 FIFO 的创建进程不存在亲缘关系的进程,只要可以访问该路径,就能够彼此通过 FIFO 相互通信,因此,通过 FIFO 不相关的进程也能交换数据。</h2><h2 id="3-信号-信号是-Linux-进程间通信的最古老的方式之一-是事件发生时对进程的通知机制-有时也称之为软件中断-它是在软件层次上对中断机制的一种模拟-是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断-转而处理某一个突发事件。"><a href="#3-信号-信号是-Linux-进程间通信的最古老的方式之一-是事件发生时对进程的通知机制-有时也称之为软件中断-它是在软件层次上对中断机制的一种模拟-是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断-转而处理某一个突发事件。" class="headerlink" title="3. 信号 信号是 Linux 进程间通信的最古老的方式之一,是事件发生时对进程的通知机制,有时也称之为软件中断,它是在软件层次上对中断机制的一种模拟,是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件。"></a>3. 信号 信号是 Linux 进程间通信的最古老的方式之一,是事件发生时对进程的通知机制,有时也称之为软件中断,它是在软件层次上对中断机制的一种模拟,是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件。</h2><h2 id="4-消息队列-消息队列就是一个消息的链表-可以把消息看作一个记录-具有特定的格式以及特定的优先级-对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息-对消息队列有读权限的进程则可以从消息队列中读走消息-消息队列是随内核持续的。"><a href="#4-消息队列-消息队列就是一个消息的链表-可以把消息看作一个记录-具有特定的格式以及特定的优先级-对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息-对消息队列有读权限的进程则可以从消息队列中读走消息-消息队列是随内核持续的。" class="headerlink" title="4. 消息队列 消息队列就是一个消息的链表,可以把消息看作一个记录,具有特定的格式以及特定的优先级,对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程则可以从消息队列中读走消息,消息队列是随内核持续的。"></a>4. 消息队列 消息队列就是一个消息的链表,可以把消息看作一个记录,具有特定的格式以及特定的优先级,对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程则可以从消息队列中读走消息,消息队列是随内核持续的。</h2><h2 id="5-共享内存-共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分-因此这种-IPC-机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中-并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比-这种-IPC-技术的速度更快。"><a href="#5-共享内存-共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分-因此这种-IPC-机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中-并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比-这种-IPC-技术的速度更快。" class="headerlink" title="5. 共享内存 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分,因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中,并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比,这种 IPC 技术的速度更快。"></a>5. 共享内存 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分,因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中,并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比,这种 IPC 技术的速度更快。</h2><h2 id="6-内存映射-内存映射（Memory-mapped-I-x2F-O）是将磁盘文件的数据映射到内存-用户通过修改内存就能修改磁盘文件。"><a href="#6-内存映射-内存映射（Memory-mapped-I-x2F-O）是将磁盘文件的数据映射到内存-用户通过修改内存就能修改磁盘文件。" class="headerlink" title="6. 内存映射 内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件。"></a>6. 内存映射 内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件。</h2><h2 id="7-信号量-信号量主要用来解决进程和线程间并发执行时的同步问题-进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为-P-操作和-V-操作-P-操作是将信号量的值减-1-V-操作是将信号量的值加-1。当信号量的值小于等于-0-之后-再进行-P-操作时-当前进程或线程会被阻塞-直到另一个进程或线程执行了-V-操作将信号量的值增加到大于-0-之时。"><a href="#7-信号量-信号量主要用来解决进程和线程间并发执行时的同步问题-进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为-P-操作和-V-操作-P-操作是将信号量的值减-1-V-操作是将信号量的值加-1。当信号量的值小于等于-0-之后-再进行-P-操作时-当前进程或线程会被阻塞-直到另一个进程或线程执行了-V-操作将信号量的值增加到大于-0-之时。" class="headerlink" title="7. 信号量 信号量主要用来解决进程和线程间并发执行时的同步问题,进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作,P 操作是将信号量的值减 1,V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后,再进行 P 操作时,当前进程或线程会被阻塞,直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。"></a>7. 信号量 信号量主要用来解决进程和线程间并发执行时的同步问题,进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作,P 操作是将信号量的值减 1,V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后,再进行 P 操作时,当前进程或线程会被阻塞,直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。</h2><h2 id="8-Socket-套接字（Socket）-就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端-提供了应用层进程利用网络协议交换数据的机制。Socket-一般用于网络中不同主机上的进程之间的通信。"><a href="#8-Socket-套接字（Socket）-就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端-提供了应用层进程利用网络协议交换数据的机制。Socket-一般用于网络中不同主机上的进程之间的通信。" class="headerlink" title="8. Socket 套接字（Socket）,就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端,提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。"></a>8. Socket 套接字（Socket）,就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端,提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/13/%E5%85%AB%E8%82%A1%E6%96%87/" data-id="cl5lxcyjm0000bcuo3k7s30ez" data-title="八股文" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-我的第一篇文章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" class="article-date">
  <time class="dt-published" datetime="2022-06-01T15:38:07.000Z" itemprop="datePublished">2022-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/">队列和广度优先搜索</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><ul>
<li><p>广度优先搜索（BFS）是一种遍历或搜索数据结构（如<code>树</code>或<code>图</code>）的算法。</p>
</li>
<li><p>我们可以使用 BFS 在<code>树</code>中执行层序遍历。</p>
</li>
<li><p>广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。</p>
</li>
<li><p>在第一轮中，我们处理根结点。在第二轮中，我们处理根结点旁边的结点；在第三轮中，我们处理距根结点两步的结点；等等等等。</p>
</li>
<li><p>与树的层序遍历类似，越是接近根结点的结点将越早地遍历。</p>
</li>
<li><p>如果在第 k 轮中将结点 X 添加到队列中，则根结点与 X 之间的最短路径的长度恰好是 k。也就是说，第一次找到目标结点时，你已经处于最短路径中。</p>
</li>
<li><p>我们首先将根结点排入队列。然后在每一轮中，我们逐个处理已经在队列中的结点，并将所有邻居添加到队列中。值得注意的是，新添加的节点不会立即遍历，而是在下一轮中处理。</p>
</li>
<li><p>结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" data-id="cl3wns4ki0001aguodg149nw5" data-title="队列和广度优先搜索" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/01/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-06-01T15:34:30.742Z" itemprop="datePublished">2022-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/01/hello-world/" data-id="cl3wns4iy0000aguo144t0dey" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%872/">八股文2</a>
          </li>
        
          <li>
            <a href="/2022/06/17/%E5%85%AB%E8%82%A1%E6%96%871/">八股文1</a>
          </li>
        
          <li>
            <a href="/2022/06/13/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
          </li>
        
          <li>
            <a href="/2022/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/">队列和广度优先搜索</a>
          </li>
        
          <li>
            <a href="/2022/06/01/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>