<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>八股文2 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="说说你对AOP的理解AOP是一种编程思想,是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。面向对象编程将程序抽象成各个层次的对象,而面向切面编程是将程序抽象成各个切面。所谓切面,相当于应用对象间的横切点,我们可以将其单独抽象为单独的模块。 AOP技术利用一种称为“横切”的技术,剖解开封装对象的内部,将影响多个类的公共行为封装到一个可重用的模块中,并将其命">
<meta property="og:type" content="article">
<meta property="og:title" content="八股文2">
<meta property="og:url" content="http://example.com/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%872/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="说说你对AOP的理解AOP是一种编程思想,是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。面向对象编程将程序抽象成各个层次的对象,而面向切面编程是将程序抽象成各个切面。所谓切面,相当于应用对象间的横切点,我们可以将其单独抽象为单独的模块。 AOP技术利用一种称为“横切”的技术,剖解开封装对象的内部,将影响多个类的公共行为封装到一个可重用的模块中,并将其命">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-07-15T15:38:07.000Z">
<meta property="article:modified_time" content="2022-07-15T07:10:55.352Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-八股文2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%872/" class="article-date">
  <time class="dt-published" datetime="2022-07-15T15:38:07.000Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      八股文2
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="说说你对AOP的理解"><a href="#说说你对AOP的理解" class="headerlink" title="说说你对AOP的理解"></a>说说你对AOP的理解</h1><h2 id="AOP是一种编程思想-是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。"><a href="#AOP是一种编程思想-是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。" class="headerlink" title="AOP是一种编程思想,是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。"></a>AOP是一种编程思想,是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。</h2><pre><code>面向对象编程将程序抽象成各个层次的对象,而面向切面编程是将程序抽象成各个切面。所谓切面,相当于应用对象间的横切点,我们可以将其单独抽象为单独的模块。
AOP技术利用一种称为“横切”的技术,剖解开封装对象的内部,将影响多个类的公共行为封装到一个可重用的模块中,并将其命名为切面。所谓的切面,简单来说就是与业务无关,却为业务模块所共同调用的逻辑,将其封装起来便于减少系统的重复代码,降低模块的耦合度,有利用未来的可操作性和可维护性。
</code></pre>
<p>AOP可以有多种实现方式,而Spring AOP支持如下两种实现方式。 </p>
<ul>
<li>JDK动态代理：这是Java提供的动态代理技术,可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式,在接口的代理实例中织入代码。 </li>
<li>CGLib动态代理：采用底层的字节码技术,在运行时创建子类代理的实例。当目标对象不存在接口时,Spring AOP就会采用这种方式,在子类实例中织入代码。</li>
</ul>
<h1 id="redis的持久化策略"><a href="#redis的持久化策略" class="headerlink" title="redis的持久化策略"></a>redis的持久化策略</h1><p>reids的持久化方式有两种：RDB和AOF </p>
<ul>
<li>RDB：它是通过数据集快照的方式来记录redis中的所有数据，在某个时间段内，将数据写入一个临时文件中，持久化结束，用这个临时文件替换上次的持久化文件，达到数据恢复。好处：只有一个dump.rdb文件，便于存储，容灾性较好，性能最大化，子进程来完成写操作，主进程继续处理命令。缺点：数据安全性低，RDB是隔一段时间进行一次备份，在此期间，如果发生了异常，可能导致数据的不完整性。 </li>
<li>AOF：它是通过记录redis的所有命令，每执行一次就记录一次数据，保存在AOF文件中。优点：保证了数据的安全性和完整性，即便是中途宕机，也可以恢复过来。缺点：他的文件比RDB文件大，如果是数据集大的时候，他的恢复速度比RDB文件慢，启动速度也慢。 Redis默认是用RDB文件存储。</li>
</ul>
<h1 id="请你说说虚拟内存和物理内存的区别"><a href="#请你说说虚拟内存和物理内存的区别" class="headerlink" title="请你说说虚拟内存和物理内存的区别"></a>请你说说虚拟内存和物理内存的区别</h1><h2 id="物理内存：计算机中真实拥有的内存。物理内存是有限的，容易产生内存不足问题。虚拟内存是一种抽象的逻辑概念，拥有连续的内存地址。"><a href="#物理内存：计算机中真实拥有的内存。物理内存是有限的，容易产生内存不足问题。虚拟内存是一种抽象的逻辑概念，拥有连续的内存地址。" class="headerlink" title="物理内存：计算机中真实拥有的内存。物理内存是有限的，容易产生内存不足问题。虚拟内存是一种抽象的逻辑概念，拥有连续的内存地址。"></a>物理内存：计算机中真实拥有的内存。物理内存是有限的，容易产生内存不足问题。虚拟内存是一种抽象的逻辑概念，拥有连续的内存地址。</h2><h1 id="说说你对IoC的理解"><a href="#说说你对IoC的理解" class="headerlink" title="说说你对IoC的理解"></a>说说你对IoC的理解</h1><h2 id="IoC：控制反转。控制：对象的创建的控制权限；反转：将对象的控制权限交给spring。之前我们创建对象时用new，现在直接从spring容器中取，维护对象之间的依赖关系，降低对象之间的耦合度。-实现方式为DI-依赖注入，有三种注入方式：构造器、setter、接口注入"><a href="#IoC：控制反转。控制：对象的创建的控制权限；反转：将对象的控制权限交给spring。之前我们创建对象时用new，现在直接从spring容器中取，维护对象之间的依赖关系，降低对象之间的耦合度。-实现方式为DI-依赖注入，有三种注入方式：构造器、setter、接口注入" class="headerlink" title="IoC：控制反转。控制：对象的创建的控制权限；反转：将对象的控制权限交给spring。之前我们创建对象时用new，现在直接从spring容器中取，维护对象之间的依赖关系，降低对象之间的耦合度。 实现方式为DI,依赖注入，有三种注入方式：构造器、setter、接口注入"></a>IoC：控制反转。控制：对象的创建的控制权限；反转：将对象的控制权限交给spring。之前我们创建对象时用new，现在直接从spring容器中取，维护对象之间的依赖关系，降低对象之间的耦合度。 实现方式为DI,依赖注入，有三种注入方式：构造器、setter、接口注入</h2><h1 id="请你说说内存管理"><a href="#请你说说内存管理" class="headerlink" title="请你说说内存管理"></a>请你说说内存管理</h1><h2 id="linux操作系统采用段页式内存管理方式：页式存储管理可以有效的提高内存利用率，段式内存管理能反映程序的逻辑结构并有利于段的共享。将这两种方法结合起来就形成了段页式储存管理方式。段页式储存管理方式就是先建好用户程序分成若干个段，再把每个段分成若干页，并为每个段赋予一个段名。"><a href="#linux操作系统采用段页式内存管理方式：页式存储管理可以有效的提高内存利用率，段式内存管理能反映程序的逻辑结构并有利于段的共享。将这两种方法结合起来就形成了段页式储存管理方式。段页式储存管理方式就是先建好用户程序分成若干个段，再把每个段分成若干页，并为每个段赋予一个段名。" class="headerlink" title="linux操作系统采用段页式内存管理方式：页式存储管理可以有效的提高内存利用率，段式内存管理能反映程序的逻辑结构并有利于段的共享。将这两种方法结合起来就形成了段页式储存管理方式。段页式储存管理方式就是先建好用户程序分成若干个段，再把每个段分成若干页，并为每个段赋予一个段名。"></a>linux操作系统采用段页式内存管理方式：页式存储管理可以有效的提高内存利用率，段式内存管理能反映程序的逻辑结构并有利于段的共享。将这两种方法结合起来就形成了段页式储存管理方式。段页式储存管理方式就是先建好用户程序分成若干个段，再把每个段分成若干页，并为每个段赋予一个段名。</h2><h1 id="请你说说IO多路复用（select、poll、epoll）"><a href="#请你说说IO多路复用（select、poll、epoll）" class="headerlink" title="请你说说IO多路复用（select、poll、epoll）"></a>请你说说IO多路复用（select、poll、epoll）</h1><h2 id="IO多路复用是指单个线程或进程能够处理多个IO请求。select调用主要统计有多少个文件描述符需要进行IO操作。缺点：内存开销大，支持的的文件描述符的个数有限。poll和select调用差别不大，主要是底层数据结构变成了链表，支持的文件描述符的个数无上限。epoll调用是更加高效的方式，底层数据结构使用了红黑树和链表，避免了大量的内存分配和轮询。"><a href="#IO多路复用是指单个线程或进程能够处理多个IO请求。select调用主要统计有多少个文件描述符需要进行IO操作。缺点：内存开销大，支持的的文件描述符的个数有限。poll和select调用差别不大，主要是底层数据结构变成了链表，支持的文件描述符的个数无上限。epoll调用是更加高效的方式，底层数据结构使用了红黑树和链表，避免了大量的内存分配和轮询。" class="headerlink" title="IO多路复用是指单个线程或进程能够处理多个IO请求。select调用主要统计有多少个文件描述符需要进行IO操作。缺点：内存开销大，支持的的文件描述符的个数有限。poll和select调用差别不大，主要是底层数据结构变成了链表，支持的文件描述符的个数无上限。epoll调用是更加高效的方式，底层数据结构使用了红黑树和链表，避免了大量的内存分配和轮询。"></a>IO多路复用是指单个线程或进程能够处理多个IO请求。select调用主要统计有多少个文件描述符需要进行IO操作。缺点：内存开销大，支持的的文件描述符的个数有限。poll和select调用差别不大，主要是底层数据结构变成了链表，支持的文件描述符的个数无上限。epoll调用是更加高效的方式，底层数据结构使用了红黑树和链表，避免了大量的内存分配和轮询。</h2><h1 id="请你说说MySQL的事务隔离级别"><a href="#请你说说MySQL的事务隔离级别" class="headerlink" title="请你说说MySQL的事务隔离级别"></a>请你说说MySQL的事务隔离级别</h1><h2 id="事务的隔离级别有：未提交读，提交读，可重复读，串行化四种隔离级别。-数据库多个事务同时执行时可能造成事务的一致性问题：脏读，不可重复读，幻读；-提交读可以解决脏读的问题：脏读就是线程A修改一个数据，没有提交，线程B读取了这个修改的数据之后线程A回滚，线程B读取到的数据就变成了脏数据。-可重复读可以解决脏读和不可重复度的问题，不可重复读就是事务A多次读取一个数据，事务B在A读取的过程中进行了修改，导致事务A多次读取到的数据不一致。-串行化可以同时解决三个问题，幻读就是事务A对一个表进行读取，事务B在A读取的时候增减或者删除数据，导致事务A读取到的数据并不一致。"><a href="#事务的隔离级别有：未提交读，提交读，可重复读，串行化四种隔离级别。-数据库多个事务同时执行时可能造成事务的一致性问题：脏读，不可重复读，幻读；-提交读可以解决脏读的问题：脏读就是线程A修改一个数据，没有提交，线程B读取了这个修改的数据之后线程A回滚，线程B读取到的数据就变成了脏数据。-可重复读可以解决脏读和不可重复度的问题，不可重复读就是事务A多次读取一个数据，事务B在A读取的过程中进行了修改，导致事务A多次读取到的数据不一致。-串行化可以同时解决三个问题，幻读就是事务A对一个表进行读取，事务B在A读取的时候增减或者删除数据，导致事务A读取到的数据并不一致。" class="headerlink" title="事务的隔离级别有：未提交读，提交读，可重复读，串行化四种隔离级别。 数据库多个事务同时执行时可能造成事务的一致性问题：脏读，不可重复读，幻读； 提交读可以解决脏读的问题：脏读就是线程A修改一个数据，没有提交，线程B读取了这个修改的数据之后线程A回滚，线程B读取到的数据就变成了脏数据。 可重复读可以解决脏读和不可重复度的问题，不可重复读就是事务A多次读取一个数据，事务B在A读取的过程中进行了修改，导致事务A多次读取到的数据不一致。 串行化可以同时解决三个问题，幻读就是事务A对一个表进行读取，事务B在A读取的时候增减或者删除数据，导致事务A读取到的数据并不一致。"></a>事务的隔离级别有：未提交读，提交读，可重复读，串行化四种隔离级别。 数据库多个事务同时执行时可能造成事务的一致性问题：脏读，不可重复读，幻读； 提交读可以解决脏读的问题：脏读就是线程A修改一个数据，没有提交，线程B读取了这个修改的数据之后线程A回滚，线程B读取到的数据就变成了脏数据。 可重复读可以解决脏读和不可重复度的问题，不可重复读就是事务A多次读取一个数据，事务B在A读取的过程中进行了修改，导致事务A多次读取到的数据不一致。 串行化可以同时解决三个问题，幻读就是事务A对一个表进行读取，事务B在A读取的时候增减或者删除数据，导致事务A读取到的数据并不一致。</h2><h1 id="如何利用Redis实现一个分布式锁？"><a href="#如何利用Redis实现一个分布式锁？" class="headerlink" title="如何利用Redis实现一个分布式锁？"></a>如何利用Redis实现一个分布式锁？</h1><h2 id="最简单redis分布式锁的实现方式：加锁：setnx（key-1），解锁：del-key-问题：如果客户忘记解锁，将会出现死锁。第二种分布式锁的实现方式：setnx-key-1-expire-key-30-解锁：del-key-问题：由于setnx和expire的非原子性，当第二步挂掉，仍然会出现死锁。第三种方式：加锁：将setnx和expire变成原子性操作，set-key-1-30-NX-解锁：del（key）。同时考虑到线程A还在执行，但是锁已经到期，当线程A执行结束时去释放锁时，可能就会释放别的线程锁，所以在解锁时要先判断一下value值，看是不是该锁，如果是，再进行删除。"><a href="#最简单redis分布式锁的实现方式：加锁：setnx（key-1），解锁：del-key-问题：如果客户忘记解锁，将会出现死锁。第二种分布式锁的实现方式：setnx-key-1-expire-key-30-解锁：del-key-问题：由于setnx和expire的非原子性，当第二步挂掉，仍然会出现死锁。第三种方式：加锁：将setnx和expire变成原子性操作，set-key-1-30-NX-解锁：del（key）。同时考虑到线程A还在执行，但是锁已经到期，当线程A执行结束时去释放锁时，可能就会释放别的线程锁，所以在解锁时要先判断一下value值，看是不是该锁，如果是，再进行删除。" class="headerlink" title="最简单redis分布式锁的实现方式：加锁：setnx（key,1），解锁：del(key),问题：如果客户忘记解锁，将会出现死锁。第二种分布式锁的实现方式：setnx(key,1)+expire(key,30),解锁：del(key).问题：由于setnx和expire的非原子性，当第二步挂掉，仍然会出现死锁。第三种方式：加锁：将setnx和expire变成原子性操作，set(key,1,30,NX),解锁：del（key）。同时考虑到线程A还在执行，但是锁已经到期，当线程A执行结束时去释放锁时，可能就会释放别的线程锁，所以在解锁时要先判断一下value值，看是不是该锁，如果是，再进行删除。"></a>最简单redis分布式锁的实现方式：加锁：setnx（key,1），解锁：del(key),问题：如果客户忘记解锁，将会出现死锁。第二种分布式锁的实现方式：setnx(key,1)+expire(key,30),解锁：del(key).问题：由于setnx和expire的非原子性，当第二步挂掉，仍然会出现死锁。第三种方式：加锁：将setnx和expire变成原子性操作，set(key,1,30,NX),解锁：del（key）。同时考虑到线程A还在执行，但是锁已经到期，当线程A执行结束时去释放锁时，可能就会释放别的线程锁，所以在解锁时要先判断一下value值，看是不是该锁，如果是，再进行删除。</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%872/" data-id="cl5m4giz3000084uofarb88kc" data-title="八股文2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/06/17/%E5%85%AB%E8%82%A1%E6%96%871/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">八股文1</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%872/">八股文2</a>
          </li>
        
          <li>
            <a href="/2022/06/17/%E5%85%AB%E8%82%A1%E6%96%871/">八股文1</a>
          </li>
        
          <li>
            <a href="/2022/06/13/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
          </li>
        
          <li>
            <a href="/2022/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/">队列和广度优先搜索</a>
          </li>
        
          <li>
            <a href="/2022/06/01/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>