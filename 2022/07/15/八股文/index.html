<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>八股文1 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="线程和进程的区别  进程有独立的地址空间,线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间；    进程和线程切换时,需要切换进程和线程的上下文,进程的上下文切换时间开销远远大于线程上下文切换时间,耗费资源较大,效率要差一些；    进程的并发性较低,线程的并发性较高；    每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口,但是线程不能够独立执行,必须依存在应用程序中,由应用">
<meta property="og:type" content="article">
<meta property="og:title" content="八股文1">
<meta property="og:url" content="http://example.com/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="线程和进程的区别  进程有独立的地址空间,线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间；    进程和线程切换时,需要切换进程和线程的上下文,进程的上下文切换时间开销远远大于线程上下文切换时间,耗费资源较大,效率要差一些；    进程的并发性较低,线程的并发性较高；    每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口,但是线程不能够独立执行,必须依存在应用程序中,由应用">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-07-15T15:38:07.000Z">
<meta property="article:modified_time" content="2022-07-15T06:33:20.207Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-八股文" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%87/" class="article-date">
  <time class="dt-published" datetime="2022-07-15T15:38:07.000Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      八股文1
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h1><ul>
<li><ol>
<li>进程有独立的地址空间,线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间；</li>
</ol>
</li>
<li><ol start="2">
<li>进程和线程切换时,需要切换进程和线程的上下文,进程的上下文切换时间开销远远大于线程上下文切换时间,耗费资源较大,效率要差一些；</li>
</ol>
</li>
<li><ol start="3">
<li>进程的并发性较低,线程的并发性较高；</li>
</ol>
</li>
<li><ol start="4">
<li>每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口,但是线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制；</li>
</ol>
</li>
<li><ol start="5">
<li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言,除了 CPU 外,系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源）,线程组之间只能共享资源；</li>
</ol>
</li>
<li><ol start="6">
<li>一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>
</ol>
</li>
</ul>
<p>得分点 地址空间、开销、并发性、内存</p>
<h1 id="请你说说MySQL索引-以及它们的好处和坏处"><a href="#请你说说MySQL索引-以及它们的好处和坏处" class="headerlink" title="请你说说MySQL索引,以及它们的好处和坏处"></a>请你说说MySQL索引,以及它们的好处和坏处</h1><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li>索引就像指向表行的指针,是一种允许查询操作快速确定哪些行符合WHERE子句中的条件,并检索到这些行的其他列值的数据结构；</li>
<li>索引主要有普通索引、唯一索引、主键索引、外键索引、全文索引、复合索引几种； </li>
<li>在大数据量的查询中,合理使用索引的优点非常明显,不仅能大幅提高匹配where条件的检索效率,还能用于排序和分组操作的加速。<h2 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h2></li>
<li>比如索引必定会增加存储资源的消耗；</li>
<li>同时也增大了插入、更新和删除操作的维护成本,因为每个增删改操作后相应列的索引都必须被更新。<h1 id="Java基本数据类型和引用类型"><a href="#Java基本数据类型和引用类型" class="headerlink" title="Java基本数据类型和引用类型"></a>Java基本数据类型和引用类型</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2></li>
<li>分别为整数类型byte&#x2F;short&#x2F;int&#x2F;long,浮点类型float&#x2F;double，字符类型char，布尔类型boolean</li>
<li>引用类型包括数组、类、接口类型，还有一种特殊的null类型</li>
</ul>
<h1 id="请介绍一下访问修饰符"><a href="#请介绍一下访问修饰符" class="headerlink" title="请介绍一下访问修饰符"></a>请介绍一下访问修饰符</h1><ul>
<li>java提供的三个访问修饰符分别表示三个访问级别之外还有一个不加修饰符的访问级别</li>
<li>访问级别控制从小到大分别为private、default、protected、public</li>
<li>private：类中被private修饰的成员只能在当前类的内部被访问。根据这点,我们可以使用它来修饰成员变量,从而将成员变量隐藏在这个类的内部。</li>
<li>default：如果类中的成员或者一个外部类不使用任何访问修饰符来进行修饰,那么他就是default级别的,default访问控制的类成员或者外部类可以被相同包下的其他类访问。</li>
<li>protected：如果一个类成员被protected访问修饰符修饰,那么这个成员不但可以被同一个包下的其他类访问,还可以被其他包下的子类访问。</li>
<li>public：这是Java中最宽松的访问级别,如果类成员被这个修饰符修饰,那么无论访问类和被访问类在不在一个包下,有没有父子关系,这个类成员都可以被访问到。</li>
</ul>
<h1 id="请你介绍一下数据库的ACID"><a href="#请你介绍一下数据库的ACID" class="headerlink" title="请你介绍一下数据库的ACID"></a>请你介绍一下数据库的ACID</h1><p>事务需遵循ACID四个特性： </p>
<ul>
<li>A（atomicity）,原子性。原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功,整个事务的执行才算成功。事务中任何一个SQL语句执行失败,那么已经执行成功的SQL语句也必须撤销,数据库状态应该退回到执行事务前的状态。 </li>
<li>C（consistency）,一致性。一致性指事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后,数据库的完整性约束没有被破坏。</li>
<li>I（isolation）,隔离性。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离,即该事务提交前对其他事务都不可见,这通常使用锁来实现。 </li>
<li>D（durability）,持久性.事务一旦提交,其结果就是永久性的,即使发生宕机等故障,数据库也能将数据恢复。持久性保证的是事务系统的高可靠性,而不是高可用性。</li>
</ul>
<h1 id="请你说说多线程"><a href="#请你说说多线程" class="headerlink" title="请你说说多线程"></a>请你说说多线程</h1><ul>
<li>线程是操作系统调度的最小单位,它可以让一个进程并发地处理多个任务,也叫轻量级进程。</li>
<li>在一个进程里可以创建多个线程,这些线程都拥有各自的计数器、堆栈、局部变量,并且能够共享进程内的资源。</li>
<li>由于共享资源,处理器便可以在这些线程之间快速切换,从而让使用者感觉这些线程在同时执行。</li>
</ul>
<p>总的来说,操作系统可以同时执行多个任务,每个任务就是一个进程。进程可以同时执行多个任务,每个任务就是一个线程。一个程序运行之后至少有一个进程,而一个进程可以包含多个线程,但至少要包含一个线程。</p>
<h3 id="使用多线程的原因主要有以下几点："><a href="#使用多线程的原因主要有以下几点：" class="headerlink" title="使用多线程的原因主要有以下几点："></a>使用多线程的原因主要有以下几点：</h3><ul>
<li><ol>
<li>更多的CPU核心</li>
</ol>
</li>
<li><ol start="2">
<li>更快的响应时间</li>
</ol>
</li>
<li><ol start="3">
<li>更好的编程模型</li>
</ol>
</li>
</ul>
<h1 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全"></a>怎么保证线程安全</h1><h2 id="Java保证线程安全的方式有很多-其中较为常用的有三种-按照资源占用情况由轻到重排列-这三种保证线程安全的方式分别是原子类、volatile、锁。"><a href="#Java保证线程安全的方式有很多-其中较为常用的有三种-按照资源占用情况由轻到重排列-这三种保证线程安全的方式分别是原子类、volatile、锁。" class="headerlink" title="Java保证线程安全的方式有很多,其中较为常用的有三种,按照资源占用情况由轻到重排列,这三种保证线程安全的方式分别是原子类、volatile、锁。"></a>Java保证线程安全的方式有很多,其中较为常用的有三种,按照资源占用情况由轻到重排列,这三种保证线程安全的方式分别是原子类、volatile、锁。</h2><ul>
<li>JDK从1.5开始提供了java.util.concurrent.atomic包,这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。在atomic包里一共提供了17个类,按功能可以归纳为4种类型的原子更新方式,分别是原子更新基本类型、原子更新引用类型、原子更新属性、原子更新数组。无论原子更新哪种类型,都要遵循“比较和替换”规则,即比较要更新的值是否等于期望值,如果是则更新,如果不是则失败。</li>
<li>volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性”,从而可以保证单个变量读写时的线程安全。</li>
<li>原子类和volatile只能保证单个共享变量的线程安全,锁则可以保证临界区内的多个共享变量的线程安全,Java中加锁的方式有两种,分别是synchronized关键字和Lock接口。synchronized是比较早期的API,在设计之初没有考虑到超时机制、非阻塞形式,以及多个条件变量。<h3 id="synchronized是比较早期的API-在设计之初没有考虑到超时机制、非阻塞形式-以及多个条件变量。若想通过升级的方式让它支持这些相对复杂的功能-则需要大改它的语法结构-不利于兼容旧代码。JDK的开发团队在1-5新增了Lock接口-并通过Lock支持了上述的功能-即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。"><a href="#synchronized是比较早期的API-在设计之初没有考虑到超时机制、非阻塞形式-以及多个条件变量。若想通过升级的方式让它支持这些相对复杂的功能-则需要大改它的语法结构-不利于兼容旧代码。JDK的开发团队在1-5新增了Lock接口-并通过Lock支持了上述的功能-即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。" class="headerlink" title="synchronized是比较早期的API,在设计之初没有考虑到超时机制、非阻塞形式,以及多个条件变量。若想通过升级的方式让它支持这些相对复杂的功能,则需要大改它的语法结构,不利于兼容旧代码。JDK的开发团队在1.5新增了Lock接口,并通过Lock支持了上述的功能,即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。"></a>synchronized是比较早期的API,在设计之初没有考虑到超时机制、非阻塞形式,以及多个条件变量。若想通过升级的方式让它支持这些相对复杂的功能,则需要大改它的语法结构,不利于兼容旧代码。JDK的开发团队在1.5新增了Lock接口,并通过Lock支持了上述的功能,即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。</h3></li>
</ul>
<h1 id="请你说说死锁定义及发生的条件"><a href="#请你说说死锁定义及发生的条件" class="headerlink" title="请你说说死锁定义及发生的条件"></a>请你说说死锁定义及发生的条件</h1><h2 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h2><h3 id="两个或两个以上的进程在执行过程中-因争夺共享资源而造成的一种互相等待的现象-若无外力作用-它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。"><a href="#两个或两个以上的进程在执行过程中-因争夺共享资源而造成的一种互相等待的现象-若无外力作用-它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。" class="headerlink" title="两个或两个以上的进程在执行过程中,因争夺共享资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。"></a>两个或两个以上的进程在执行过程中,因争夺共享资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。</h3><h2 id="2-死锁的发生必须具备以下四个必要条件："><a href="#2-死锁的发生必须具备以下四个必要条件：" class="headerlink" title="2.死锁的发生必须具备以下四个必要条件："></a>2.死锁的发生必须具备以下四个必要条件：</h2><ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用,即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源,则请求者只能等待,直至占有资源的进程用毕释放；  </li>
<li>请求和保持条件：指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已被其它进程占有,此时请求进程阻塞,但又对自己已获得的其它资源保持不放； </li>
<li>不剥夺条件：指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放； </li>
<li>环路等待条件：指在发生死锁时,必然存在一个进程——资源的环形链,即进程集合 {P0,P1,P2,···,Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源,……,Pn 正在等待已被 P0 占用的资源。</li>
</ul>
<h1 id="请你说说进程间的通信方式"><a href="#请你说说进程间的通信方式" class="headerlink" title="请你说说进程间的通信方式"></a>请你说说进程间的通信方式</h1><h2 id="进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket"><a href="#进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket" class="headerlink" title="进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket"></a>进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket</h2><h2 id="1-管道-管道也叫无名（匿名）管道-它是是-UNIX-系统-IPC（进程间通信）的最古老形式-所有的-UNIX-系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区-Linux-系统中通过-pipe-函数创建管道-会生成两个文件描述符-分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。"><a href="#1-管道-管道也叫无名（匿名）管道-它是是-UNIX-系统-IPC（进程间通信）的最古老形式-所有的-UNIX-系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区-Linux-系统中通过-pipe-函数创建管道-会生成两个文件描述符-分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。" class="headerlink" title="1. 管道 管道也叫无名（匿名）管道,它是是 UNIX 系统 IPC（进程间通信）的最古老形式,所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区,Linux 系统中通过 pipe() 函数创建管道,会生成两个文件描述符,分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。"></a>1. 管道 管道也叫无名（匿名）管道,它是是 UNIX 系统 IPC（进程间通信）的最古老形式,所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区,Linux 系统中通过 pipe() 函数创建管道,会生成两个文件描述符,分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。</h2><h2 id="2-命名管道-匿名管道-由于没有名字-只能用于亲缘关系的进程间通信。为了克服这个缺点-提出了有名管道（FIFO）-也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联-以-FIFO-的文件形式存在于文件系统中-并且其打开方式与打开一个普通文件是一样的-这样即使与-FIFO-的创建进程不存在亲缘关系的进程-只要可以访问该路径-就能够彼此通过-FIFO-相互通信-因此-通过-FIFO-不相关的进程也能交换数据。"><a href="#2-命名管道-匿名管道-由于没有名字-只能用于亲缘关系的进程间通信。为了克服这个缺点-提出了有名管道（FIFO）-也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联-以-FIFO-的文件形式存在于文件系统中-并且其打开方式与打开一个普通文件是一样的-这样即使与-FIFO-的创建进程不存在亲缘关系的进程-只要可以访问该路径-就能够彼此通过-FIFO-相互通信-因此-通过-FIFO-不相关的进程也能交换数据。" class="headerlink" title="2. 命名管道 匿名管道,由于没有名字,只能用于亲缘关系的进程间通信。为了克服这个缺点,提出了有名管道（FIFO）,也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联,以 FIFO 的文件形式存在于文件系统中,并且其打开方式与打开一个普通文件是一样的,这样即使与 FIFO 的创建进程不存在亲缘关系的进程,只要可以访问该路径,就能够彼此通过 FIFO 相互通信,因此,通过 FIFO 不相关的进程也能交换数据。"></a>2. 命名管道 匿名管道,由于没有名字,只能用于亲缘关系的进程间通信。为了克服这个缺点,提出了有名管道（FIFO）,也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联,以 FIFO 的文件形式存在于文件系统中,并且其打开方式与打开一个普通文件是一样的,这样即使与 FIFO 的创建进程不存在亲缘关系的进程,只要可以访问该路径,就能够彼此通过 FIFO 相互通信,因此,通过 FIFO 不相关的进程也能交换数据。</h2><h2 id="3-信号-信号是-Linux-进程间通信的最古老的方式之一-是事件发生时对进程的通知机制-有时也称之为软件中断-它是在软件层次上对中断机制的一种模拟-是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断-转而处理某一个突发事件。"><a href="#3-信号-信号是-Linux-进程间通信的最古老的方式之一-是事件发生时对进程的通知机制-有时也称之为软件中断-它是在软件层次上对中断机制的一种模拟-是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断-转而处理某一个突发事件。" class="headerlink" title="3. 信号 信号是 Linux 进程间通信的最古老的方式之一,是事件发生时对进程的通知机制,有时也称之为软件中断,它是在软件层次上对中断机制的一种模拟,是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件。"></a>3. 信号 信号是 Linux 进程间通信的最古老的方式之一,是事件发生时对进程的通知机制,有时也称之为软件中断,它是在软件层次上对中断机制的一种模拟,是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件。</h2><h2 id="4-消息队列-消息队列就是一个消息的链表-可以把消息看作一个记录-具有特定的格式以及特定的优先级-对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息-对消息队列有读权限的进程则可以从消息队列中读走消息-消息队列是随内核持续的。"><a href="#4-消息队列-消息队列就是一个消息的链表-可以把消息看作一个记录-具有特定的格式以及特定的优先级-对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息-对消息队列有读权限的进程则可以从消息队列中读走消息-消息队列是随内核持续的。" class="headerlink" title="4. 消息队列 消息队列就是一个消息的链表,可以把消息看作一个记录,具有特定的格式以及特定的优先级,对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程则可以从消息队列中读走消息,消息队列是随内核持续的。"></a>4. 消息队列 消息队列就是一个消息的链表,可以把消息看作一个记录,具有特定的格式以及特定的优先级,对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程则可以从消息队列中读走消息,消息队列是随内核持续的。</h2><h2 id="5-共享内存-共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分-因此这种-IPC-机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中-并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比-这种-IPC-技术的速度更快。"><a href="#5-共享内存-共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分-因此这种-IPC-机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中-并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比-这种-IPC-技术的速度更快。" class="headerlink" title="5. 共享内存 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分,因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中,并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比,这种 IPC 技术的速度更快。"></a>5. 共享内存 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分,因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中,并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比,这种 IPC 技术的速度更快。</h2><h2 id="6-内存映射-内存映射（Memory-mapped-I-x2F-O）是将磁盘文件的数据映射到内存-用户通过修改内存就能修改磁盘文件。"><a href="#6-内存映射-内存映射（Memory-mapped-I-x2F-O）是将磁盘文件的数据映射到内存-用户通过修改内存就能修改磁盘文件。" class="headerlink" title="6. 内存映射 内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件。"></a>6. 内存映射 内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件。</h2><h2 id="7-信号量-信号量主要用来解决进程和线程间并发执行时的同步问题-进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为-P-操作和-V-操作-P-操作是将信号量的值减-1-V-操作是将信号量的值加-1。当信号量的值小于等于-0-之后-再进行-P-操作时-当前进程或线程会被阻塞-直到另一个进程或线程执行了-V-操作将信号量的值增加到大于-0-之时。"><a href="#7-信号量-信号量主要用来解决进程和线程间并发执行时的同步问题-进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为-P-操作和-V-操作-P-操作是将信号量的值减-1-V-操作是将信号量的值加-1。当信号量的值小于等于-0-之后-再进行-P-操作时-当前进程或线程会被阻塞-直到另一个进程或线程执行了-V-操作将信号量的值增加到大于-0-之时。" class="headerlink" title="7. 信号量 信号量主要用来解决进程和线程间并发执行时的同步问题,进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作,P 操作是将信号量的值减 1,V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后,再进行 P 操作时,当前进程或线程会被阻塞,直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。"></a>7. 信号量 信号量主要用来解决进程和线程间并发执行时的同步问题,进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作,P 操作是将信号量的值减 1,V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后,再进行 P 操作时,当前进程或线程会被阻塞,直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。</h2><h2 id="8-Socket-套接字（Socket）-就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端-提供了应用层进程利用网络协议交换数据的机制。Socket-一般用于网络中不同主机上的进程之间的通信。"><a href="#8-Socket-套接字（Socket）-就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端-提供了应用层进程利用网络协议交换数据的机制。Socket-一般用于网络中不同主机上的进程之间的通信。" class="headerlink" title="8. Socket 套接字（Socket）,就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端,提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。"></a>8. Socket 套接字（Socket）,就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端,提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%87/" data-id="cl5lxcyjm0000bcuo3k7s30ez" data-title="八股文1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%871/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">八股文2</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%87/">八股文1</a>
          </li>
        
          <li>
            <a href="/2022/07/15/%E5%85%AB%E8%82%A1%E6%96%871/">八股文2</a>
          </li>
        
          <li>
            <a href="/2022/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/">队列和广度优先搜索</a>
          </li>
        
          <li>
            <a href="/2022/06/01/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>